title: Python中奇怪的坑
authors: milo

# Python中的陷阱合集

本文会列举出，在使用Python的过程中，容易踩到的坑，并结合CPython源码，尝试解释它的原理和避坑方法。<br/>

## 一直存在的陷阱

### 循环引用太多导致出现卡顿

虽然Python中有 **标记-清除** 机制解决循环引用的问题，但这个过程是发生在 `gc.collect()` 中的，它会导致程序出现卡顿。

正常情况下，Python对象会在它的引用计数归零时马上被回收，大量的回收操作会分散在整个程序运行期间，不会出现卡顿。

但是，如果出现循环引用，Python对象的引用计数始终不为0，Python虚拟机的内存持续增加，直到达到了某个阈值，自动触发了 `gc.collect()`。

大量的循环引用，会导致内存很快达到阈值，频繁触发 `gc.collect()` ，导致卡顿。

因此，要注意避免产生循环引用，不要太过依赖 **标记-清除** 的gc回收机制。

## Python-3.4 之前的陷阱

### 循环引用无法被回收

如果循环引用中，有任意一个对象实现了魔术方法 `__del__`，那么它所在的整个环都无法被gc回收。

```python
class A(object):
    def __del__(self):  # 重写了魔术方法 __del__
        pass
        
a = A()
a.a = a  # 产生了循环引用
del a  # 因为产生了循环引用，引用计数不为0，只能等待gc

import gc
print(gc.garbage)
gc.collect()
print(gc.garbage)  # gc检测到循环引用，但是无法回收，会把它们放入gc.garbage中
```

因为对于重写了 `__del__` 方法的对象，gc认为你***可能***有一个固定的释放顺序，而gc并不知道这个顺序。
例如：现在有一个循环引用 a=>b=>c=>a，所以gc会把这样的对象（以及它所在的环）放入gc.garbage中，让你自己打破这个环。

## 参考
[程序员必知的Python陷阱与缺陷列表](https://www.cnblogs.com/xybaby/p/7183854.html)
