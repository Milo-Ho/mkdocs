# C++

### 多态

#### 静态多态（编译时）
编译器根据函数实参的类型判断出要调用哪个函数。比如函数重载和函数模板。重载的函数在编译时其实是不同的函数名和不同的函数地址，所以也有人认为函数重载不算多态。

#### 动态多态（运行时）
依靠的是虚函数表和动态绑定机制，因为是在运行时根据对象的类型在虚函数表中寻找调用函数的地址来调用相应的函数，所以称为动态多态。

在一个类的某个函数前加上virtual关键字，这个函数就变成了虚函数，当这个类中存在虚函数时，编译器会给这个类创建一个虚函数表，虚函数表里存放了这个类中所有虚函数的地址。

也就是说，虚函数表是在编译期间就已经生成了！

一个类只会有一个虚函数表，类的所有对象是共享这个虚函数表的

如果类有虚函数，那么类的每个对象的内存中都会有一个指向虚表的虚指针，通过这个虚指针，这些对象就都能访问到类的虚表。这也是为什么不管类中有多少个虚函数，对象的内存中都只会多4个字节的原因，因为每个对象的内存中只是多了一个指向这个类的虚函数表的指针。

使用virtual修饰的函数会根据实际对象的类型来调用，没有使用virtual修饰的根据指针的类型来调用。

### 覆盖与隐藏
覆盖指的是子类覆盖父类函数（被覆盖），特征是：

1. 分别位于子类和父类中
2. 函数名字与参数都相同
3. 父类的函数是虚函数（virtual）


隐藏指的是子类隐藏了父类的函数（还存在），具有以下特征：

- 子类的函数与父类的名称相同，但是参数不同，父类函数被隐藏
- 子类函数与父类函数的名称相同，参数也相同，但是父类函数没有virtual，父类函数被隐藏



参考：

https://www.bejson.com/runcode/cpp920/

https://blog.csdn.net/weixin_43222324/article/details/109767675

https://wenku.baidu.com/view/97188bf675eeaeaad1f34693daef5ef7bb0d125b.html


---
std::move
右值引用

[shared_ptr](https://www.cnblogs.com/yahoo17/p/12862958.html)

std::lock_guard

[C++11、C++14、C++17、C++20新特性总结（5万字详解）](https://blog.csdn.net/qq_41854911/article/details/119657617)
