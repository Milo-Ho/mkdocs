# Redis

zhuanlan.zhihu.com/p/462619821

灾备：RDB和AOF、多副本（主从、主备、哨兵）

怎么保证缓存和数据库的一致性？
Redis的哈希冲突、内存淘汰策略？渐进式rehash
Redis的线程模型
为什么redis是单线程还需要事务（redis是有竞态问题的）
为什么pipeline不能代替事物？
Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令
Redis事务不保证原子性，且没有回滚。事务中任意指令执行失败，其余的命令仍会被执行。


##### 缓存穿透：攻击者恶意查询不存在的数据
- 布隆过滤器（无法删除数据）
- 可以把key-null写入缓存，有效时间设置短一点（例如30s）
- 接口层增加校验

##### 缓存击穿：缓存过期，高并发、同时查询同一个key，导致数据库压力过大
- 热点数据永不过期（数据量太大，这个方案不现实）
- 加锁（redis用setnx加锁）

##### 缓存雪崩：大量数据过期，导致大量查询数据库
- 热点数据永不过期（数据量太大，这个方案不现实）
- 过期时间随机，防止同一时间大量数据过期（有的业务必须准点清空旧数据，则需要在业务层把时间分散）
- 业务层设置一个短暂的随机延迟，把时间分散
- （分布式的缓存数据库）热点数据分布在不同的缓存数据库

##### AOF
1. 进程内已超时的数据不再写入文件
2. 忽略无效指令，重写时使用进程内数据直接生成
3. 对同一数据的多条写命令合并为一条命令

##### 过期键的删除策略
1. 定时删除：定时器，时间到了就删除<br/>
节约内存，占用CPU，影响redis服务器响应时间和指令吞吐量（时间换空间）
2. 惰性删除：下次访问再处理<br/>
节约CPU，但内存压力大，可能长期占用内存（空间换时间）
3. 定期删除：定期进行随机扫描、遇到过期的就删除，如果删除的数据量大于阈值，则再执行一次<br/>
CPU有峰值，内存压力也不大，

**Redis使用惰性删除+定期删除**

##### redis内存优化
1. 控制key的数量<br/>
2. 缩减键值对象<br/>
在完整描述业务的情况下，key越短越好<br/>
Value可以序列化成二进制数组（需要高效的序列化工具）<br/>
3、编码优化<br/>
Redis对外提供了string, list, hash, set, zet等类型，但是redis内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现

##### redis用setnx加锁
1. 加锁进程死亡，锁无法被释放，死锁（加过期时间）
2. 加锁进程没来得及加过期时间就死亡了（使用redis事务）
3. 加锁成功后，一个线程照常执行业务，另一个线程监管锁的时间，保证业务执行完成之前，锁不会被释放掉

##### 分布式redis加锁
