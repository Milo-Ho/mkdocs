# MySQL

### 一、索引
##### 1、索引类型
* 从索引存储结构划分：B Tree索引、Hash索引、FULLTEXT全文索引、R Tree索引 
* 从应用层次划分：普通索引、唯一索引、主键索引、复合索引 
* 从索引键值类型划分：主键索引、辅助索引（二级索引） 
* 从数据存储和索引键值逻辑关系划分：聚集索引（聚簇索引）、非聚集索引（非聚簇索引）

普通索引<br/>
唯一索引（unique_key）：列值唯一，但允许为空<br/>
主键索引（primary_key）：特殊的唯一索引，不允许为空<br/>
联合索引（组合索引）

##### 2、使用索引的注意事项
数据唯一性差的字段，二叉树级别少，无异于全表扫描（例如，性别，只有2种选择）；

频繁更新的字段，需要维护索引，降低数据库的效率（例如，登录次数）；使用or条件会使部分索引无效；

联合索引，如果不是使用开头的部分，索引无效；

只有在where语句出现的字段，才会使用索引，其他字段不要加索引；

like查询，如果是%开头，索引无效；

索引列的数据类型隐形转换，索引无效；

where子句中对索引列有数学运算，索引无效；

where子句中对索引列使用函数，索引无效；

where子句中对索引列使用不等于<>，效果一般；

where子句中包含is null / is not null 等条件，不建议使用索引；

MySQL估计使用全表扫描比用索引快，则不使用索引（例如数据量极少的表）；

##### 3、索引分析与优化
1. 使用EXPLAIN

2. 覆盖索引<br/>
只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，这就叫做索引覆盖。 <br/>
实现索引覆盖最常见的方法就是：将被查询的字段，建立到组合索引。

3. 联合索引的最左前缀原则<br/>
查询中使用到最左边的列，那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效。

4. LIKE 查询<br/>
MySQL在使用Like模糊查询时，索引是可以被使用的，只有把%字符写在后面才会使用到索引。

5. NULL 值查询<br/>
NULL值反映在索引中的排列规则是：
    - NULL值会被归到一块。
    - 如果是升序的话，NULL值被归到数据页的前端，如果是降序的话，NULL值被归到数据页的尾端。
    - 如果有多条NULL值数据，则按先来后到的顺序依次排列。
<br/>
对MySQL来说，NULL是一个特殊的值，从概念上讲，NULL意味着“一个未知值”，它的处理方式与其他值有些不同。
<br/>
比如：不能使用=，<，>这样的运算符，对NULL做算术运算的结果都是NULL，count时不会包括NULL行等，NULL比空字符串需要更多的存储空间等。
<br/>
虽然MySQL可以在含有NULL的列上使用索引，但不代表NULL和其他数据在索引中是一样的。
<br/>
不建议列上允许为空。最好限制NOT NULL，并设置一个默认值，比如0和''空字符串等，如果是datetime类型，可以设置成'1970-01-01 00:00:00'这样的特殊值。

6. 索引和排序<br/>

    - MySQL查询支持filesort和index两种方式的排序
        * filesort是先把结果查出，然后在缓存或磁盘进行排序操作，效率较低。
        * 使用index是指利用索引自动实现排序，不需另做排序操作，效率会比较高。 

    - filesort有两种排序算法：双路排序和单路排序。 
        * 双路排序：需要两次磁盘扫描读取，最终得到用户数据。第一次将排序字段读取出来，然后排序；第二次去读取其他字段数据。 
        * 单路排序：从磁盘查询所需的所有列数据，然后在内存排序将结果返回。如果查询数据超出缓存 sort_buffer，会导致多次磁盘读取操作，并创建临时表，最后产生了多次IO，反而会增加负担。 

    - 解决方案：
	    * 少使用select *；
	    * 增加sort_buffer_size容量和max_length_for_sort_data容量。

##### 4、查询优化
（1）慢查询定位（slow_query_log）

（2）慢查询优化

需要使用索引的快速搜索功能，并且有效地减少扫描行数。

是否使用了索引和是否是慢查询两者之间没有必然的联系。

在使用索引时，不要只关注是否起作用，应该关心索引是否减少了查询扫描的数据行数，如果扫描行数减少了，效率才会得到提升。

对于一个大表，不止要创建索引，还要考虑索引过滤性，过滤性好，执行速度才会快。

（3）分页查询优化

偏移量固定，查询记录数越多，查询时间越长；

查询记录数固定，偏移量越大，查询时间越长；

利用覆盖索引+子查询优化

select * from user limit 10000,100;

select * from user where id>= (select id from user limit 10000,1) limit 100;

使用了id做主键比较(id>=)，并且子查询使用了覆盖索引进行优化。

### 二、InnoDB和MyISAM的区别

### 三、主从复制
三种方式：

- 基于语句的复制（逻辑复制）
- 基于行的复制
- 混合复制

异步复制

半同步复制

GTID复制

### 四、灾备
1 MHA
2 MMM
3 PXC
4 M-S
5 M-M
6 mysql Cluster


### 其他
MySQL 5.7 引入了虚拟列，可以使用虚拟列建立联合索引
